<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Crypto UK Tracker</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc; /* Light background */
        }
        .card {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .primary-color {
            color: #10b981; /* Emerald green */
        }
        .bg-primary {
            background-color: #10b981;
        }
        .pulse-loader {
            border-top: 4px solid #10b981;
            border-right: 4px solid transparent;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8 flex flex-col items-center">

    <header class="w-full max-w-4xl mb-8">
        <h1 class="text-4xl font-bold text-gray-800 text-center primary-color">
            My Crypto UK Tracker
        </h1>
        <p class="text-center text-gray-500 mt-2">Real-time cryptocurrency prices in GBP (£)</p>
    </header>

    <main class="w-full max-w-4xl">
        
        <!-- API KEY AND ERROR MESSAGES -->
        <div id="api-key-setup" class="card p-6 rounded-lg shadow-xl mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">API Key Required</h2>
            <p class="text-sm text-gray-600 mb-4">
                This app uses the Gemini API to fetch real-time crypto prices. Please enter your API Key below.
                (Note: Leave the API Key field empty if you are running this code within a secure Canvas environment, as the key is provided automatically.)
            </p>
            <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
                <input type="password" id="api-key-input" placeholder="Enter your Gemini API Key"
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-color">
                <button onclick="setApiKey()"
                        class="bg-primary hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out">
                    Save Key
                </button>
            </div>
            <p id="api-key-status" class="mt-3 text-sm font-medium text-gray-500"></p>
        </div>

        <div id="error-message" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-md mb-6" role="alert">
            <p class="font-bold">Error:</p>
            <p id="error-text" class="text-sm"></p>
        </div>
        
        <!-- LOADING INDICATOR -->
        <div id="loading-indicator" class="flex justify-center items-center py-12 hidden">
            <div class="pulse-loader"></div>
            <p class="ml-4 text-gray-600">Fetching live market data...</p>
        </div>

        <!-- MAIN CONTENT - TABLE -->
        <div id="crypto-table-container" class="card p-4 sm:p-6 rounded-lg shadow-xl hidden overflow-x-auto">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">Top Cryptocurrencies</h2>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Rank</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Price (GBP)</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">24h Change</th>
                    </tr>
                </thead>
                <tbody id="crypto-data-body" class="bg-white divide-y divide-gray-200">
                    <!-- Data will be inserted here -->
                </tbody>
            </table>
            
            <p id="last-updated" class="mt-4 text-xs text-gray-500 text-right"></p>
            
            <!-- Grounding Sources Display -->
            <div id="sources-container" class="mt-6 pt-4 border-t border-gray-100">
                <h3 class="text-sm font-semibold text-gray-700 mb-2">Sources (Google Search Grounding):</h3>
                <ul id="sources-list" class="space-y-1 text-sm text-gray-600">
                    <!-- Sources will be inserted here -->
                </ul>
            </div>
        </div>
        
    </main>
    
    <!-- FOOTER -->
    <footer class="w-full max-w-4xl mt-12 text-center text-sm text-gray-500">
        <p>&copy; 2025 My Crypto UK Tracker. Data provided by the Gemini API via Google Search Grounding.</p>
        <p class="mt-1">Cryptocurrency markets are volatile; this data is for informational purposes only.</p>
    </footer>

    <script>
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        let apiKey = typeof __api_key !== 'undefined' ? __api_key : ''; // Global API key variable

        const elements = {
            loading: document.getElementById('loading-indicator'),
            error: document.getElementById('error-message'),
            errorText: document.getElementById('error-text'),
            tableContainer: document.getElementById('crypto-table-container'),
            dataBody: document.getElementById('crypto-data-body'),
            lastUpdated: document.getElementById('last-updated'),
            apiKeySetup: document.getElementById('api-key-setup'),
            apiKeyInput: document.getElementById('api-key-input'),
            apiKeyStatus: document.getElementById('api-key-status'),
            sourcesList: document.getElementById('sources-list'),
        };

        // --- Utility Functions ---

        /**
         * Converts base64 encoded string to a plain ArrayBuffer.
         * @param {string} base64 The base64 string.
         * @returns {ArrayBuffer}
         */
        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Formats a number to GBP currency.
         * @param {number} num
         * @returns {string}
         */
        function formatGBP(num) {
            return new Intl.NumberFormat('en-GB', {
                style: 'currency',
                currency: 'GBP',
                minimumFractionDigits: num < 1 ? 4 : 2,
                maximumFractionDigits: num < 1 ? 8 : 2,
            }).format(num);
        }
        
        /**
         * Displays the loading spinner and hides content.
         */
        function showLoading() {
            elements.loading.classList.remove('hidden');
            elements.error.classList.add('hidden');
            elements.tableContainer.classList.add('hidden');
        }

        /**
         * Hides the loading spinner.
         */
        function hideLoading() {
            elements.loading.classList.add('hidden');
        }

        /**
         * Displays an error message.
         * @param {string} message The error message to display.
         */
        function showError(message) {
            hideLoading();
            elements.errorText.textContent = message;
            elements.error.classList.remove('hidden');
            elements.tableContainer.classList.add('hidden');
        }

        /**
         * Converts a string representing a percentage change into a styled HTML span.
         * @param {string} changeStr The percentage change string (e.g., "-2.5%" or "+5.12%").
         * @returns {string} Styled HTML span.
         */
        function formatChange(changeStr) {
            const value = parseFloat(changeStr.replace('%', ''));
            const colorClass = value >= 0 ? 'text-green-600' : 'text-red-600';
            const sign = value > 0 ? '▲ ' : (value < 0 ? '▼ ' : '');
            return `<span class="${colorClass} font-semibold">${sign}${changeStr}</span>`;
        }

        /**
         * Parses the generated text content from the LLM response into an array of crypto objects.
         * @param {string} text The raw text response from the model.
         * @returns {Array<Object> | null} Array of crypto objects or null on failure.
         */
        function parseCryptoData(text) {
            try {
                // The prompt asks the model to output a table structure. We need to parse that structure.
                const lines = text.trim().split('\n').filter(line => line.includes('|'));
                
                // Skip header and separator lines
                const dataLines = lines.slice(2); 

                return dataLines.map(line => {
                    // Split by '|', trim whitespace, and filter out empty strings
                    const parts = line.split('|').map(p => p.trim()).filter(p => p.length > 0);

                    if (parts.length < 4) {
                        throw new Error("Missing data columns in row: " + line);
                    }

                    // Extract and sanitize data
                    const rank = parseInt(parts[0].replace('.', ''), 10);
                    const nameMatch = parts[1].match(/^(.+?)\s*\((.+?)\)$/); // e.g., "Bitcoin (BTC)"
                    const priceStr = parts[2];
                    const changeStr = parts[3];
                    
                    if (!nameMatch) {
                         throw new Error("Could not parse name and symbol: " + parts[1]);
                    }

                    return {
                        rank: isNaN(rank) ? null : rank,
                        name: nameMatch[1].trim(),
                        symbol: nameMatch[2].trim(),
                        price: priceStr.replace(/£|GBP|,/g, ''), // Clean currency symbol for parsing
                        change24h: changeStr,
                    };
                });

            } catch (e) {
                console.error("Failed to parse LLM response:", e);
                showError("Failed to interpret the data from the API. Please try again.");
                return null;
            }
        }
        
        /**
         * Renders the cryptocurrency data to the HTML table.
         * @param {Array<Object>} data The parsed crypto data.
         * @param {Array<Object>} sources The grounding sources.
         */
        function renderCryptoData(data, sources) {
            elements.dataBody.innerHTML = ''; // Clear existing rows
            
            data.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition duration-100 ease-in-out';
                
                // Attempt to parse price to number for correct formatting
                const priceValue = parseFloat(item.price);
                const formattedPrice = isNaN(priceValue) ? item.price : formatGBP(priceValue);

                row.innerHTML = `
                    <td class="px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${item.rank || '-'}</td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="text-sm font-medium text-gray-900">${item.name}</div>
                        <div class="text-xs text-gray-500">${item.symbol}</div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700 text-right font-mono">${formattedPrice}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700 text-right">${formatChange(item.change24h)}</td>
                `;
                elements.dataBody.appendChild(row);
            });
            
            elements.tableContainer.classList.remove('hidden');
            elements.lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
            
            // Render Grounding Sources
            elements.sourcesList.innerHTML = '';
            if (sources && sources.length > 0) {
                sources.forEach(source => {
                    const li = document.createElement('li');
                    li.innerHTML = `<a href="${source.uri}" target="_blank" class="text-blue-500 hover:text-blue-700 hover:underline transition duration-100 ease-in-out">${source.title || source.uri}</a>`;
                    elements.sourcesList.appendChild(li);
                });
            } else {
                elements.sourcesList.innerHTML = '<li class="text-gray-400">No verifiable sources provided by the search grounding.</li>';
            }
        }
        
        /**
         * Makes a robust fetch request with exponential backoff.
         */
        async function fetchWithRetry(url, options, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Throw an error if the response status is not OK (2xx)
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i < retries - 1) {
                        // Wait using exponential backoff: 2^i * 1000 ms
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error; // Re-throw the last error
                    }
                }
            }
        }

        // --- Core Application Logic ---
        
        /**
         * Fetches crypto data using the Gemini API with Google Search Grounding.
         */
        async function fetchCryptoData() {
            if (!apiKey) {
                elements.apiKeySetup.classList.remove('hidden');
                elements.apiKeyStatus.textContent = "API Key is required to fetch data.";
                return;
            }
            
            showLoading();
            
            // Instruction to the model: Act as a market data reporter, only output a table.
            const systemPrompt = "Act as a specialized financial data terminal. Your ONLY output MUST be a Markdown table containing the Rank, Name (including the 3-letter symbol in parentheses), Price in GBP, and 24-hour Change (as a percentage, e.g., +2.5% or -1.1%). Do not include any introductory or concluding text, notes, or explanations.";
            
            // User Query: Use Google Search Grounding to get real-time data
            const userQuery = "Provide a table of the current top 10 cryptocurrencies (by market cap) with their price and 24h change, denominated in Great British Pounds (GBP).";
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }], // Enable grounding for real-time data
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                const candidate = result.candidates?.[0];

                if (!candidate || !candidate.content?.parts?.[0]?.text) {
                    const errorMessage = result.error?.message || "API call failed with no content.";
                    throw new Error(errorMessage);
                }
                
                const text = candidate.content.parts[0].text;
                
                // 1. Extract grounding sources
                let sources = [];
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title); // Ensure sources are valid
                }

                // 2. Parse and render data
                const cryptoData = parseCryptoData(text);
                
                if (cryptoData) {
                    renderCryptoData(cryptoData, sources);
                }

            } catch (error) {
                console.error("API Fetch Error:", error);
                showError("Could not fetch data. The API might be unavailable, or the provided API key is invalid/expired. Details: " + error.message);
            } finally {
                hideLoading();
            }
        }
        
        /**
         * Handles the API key input and initialization.
         */
        function setApiKey() {
            const key = elements.apiKeyInput.value.trim();
            if (key) {
                apiKey = key;
                elements.apiKeySetup.classList.add('hidden');
                elements.apiKeyStatus.textContent = "Key saved! Fetching data...";
                fetchCryptoData();
            } else {
                elements.apiKeyStatus.textContent = "Please enter a valid API Key.";
            }
        }

        // --- Initialization ---

        function initApp() {
             // Check if running in a Canvas environment (where __api_key is defined)
            if (typeof __api_key !== 'undefined' && __api_key) {
                apiKey = __api_key;
                elements.apiKeySetup.classList.add('hidden'); // Hide the input if key is auto-provided
                fetchCryptoData();
            } else if (apiKey) {
                 // Use any previously set global key if not in canvas
                 elements.apiKeySetup.classList.add('hidden'); 
                 fetchCryptoData();
            } else {
                // If no key is set, show the setup prompt
                elements.apiKeySetup.classList.remove('hidden');
                elements.apiKeyStatus.textContent = "Please enter your API Key above.";
            }
            
            // Set up auto-refresh (e.g., every 60 seconds)
            setInterval(fetchCryptoData, 60000); 
        }

        // Run the initialization logic when the window loads
        window.onload = initApp;

    </script>
</body>